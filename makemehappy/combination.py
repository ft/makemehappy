# This module implements infrastructure to run arbitrary code to combine
# results from system build instances into additional artefacts.
#
# The module exposes an instance of the Registry type called "combination",
# that the mmh program uses to access the list of combinations that a user
# decided to specify.
#
# The Registry is a mapping of a name (a string) to an instance of the
# Combination type. The Combination type is a class that has two main
# properties: a) a list of parent build instances it depends on (note that a
# Combination cannot be a parent of another Combination. This is by design and
# eliminates the possibility of dependency loops). b) a way to generate one or
# more CombinationOutput instances. This means that each combination in the
# registry can generate an arbitrary amount of artefacts.
#
# A combination output is basically a triple: A list of input files, an output
# file, and a function that can generate the latter using the former.
#
# When the state of a system allows for a combination to be executed, here is
# what happens: The generator is run to create a list of CombinationOutput
# objects. This list is traversed and for each entry, the combination callback
# is run with the input file list and output file name as arguments. The
# results of this are collected. None of the callbacks may throw or return
# False. If and of them does, the combination is marked as being unsuccessfully
# executed.
#
# In order to be able to skip generating artefacts over and over again, during
# processing, the system creates a file that captures the state of the mmh
# program, and all its loaded code, as well as the state of all input files.
# Any changes in this captured state will disallow any short-cuts from being
# taken. In addition, each Combination also gets a state file, the contents of
# which can be referenced in the state files of CombinationOutput objects. This
# allows determining, which artefacts in the binary tree where generated by the
# latest combination build run. The main mmh program builds some tooling around
# these features for additional insight.

import datetime
import hashlib
import os
import makemehappy.pathlike as p
import makemehappy.utilities as mmh

from pathlib import Path

COMBINATION_STATE_FILE_VERSION = 0
OUTPUT_STATE_FILE_VERSION = 0

class InvalidCombinationGenerator(Exception):
    pass

class CombinationOutput:
    def __init__(self, callback, name, inputs):
        self.callback = callback
        self.name = name
        self.inputs = inputs

    def run(self, outdir):
        try:
            return self.callback(self.inputs, outdir / self.name)
        except Exception as e:
            return False

class Combination:
    def __init__(self, name, parents, gen, kwargs):
        self.name = name
        self.parents = parents
        self.gen = gen
        self.kwargs = kwargs
        self.done = False
        self.status = None
        self.mmhstate = None
        self.log = None
        self.buildroot = None
        self.data = None
        self.out = None
        self.outputs = None
        self.stateFile = None
        self.algorithm = hashlib.sha256
        self.checksumCache = {}
        self.printer = None
        self.verbose = None

    def _validOuputs(self, lst):
        if isinstance(lst, list) is False:
            return False
        return all(map(lambda x: isinstance(x, CombinationOutput), lst))

    def ensureLog(self, log):
        if self.log is not None:
            return
        self.log = log
        self.printer = self.log.info
        if mmh.verbosity > 0:
            self.verbose = self.log.info
        else:
            self.verbose = lambda x: True

    def skipped(self):
        return (self.status is None)

    def succeeded(self):
        return (self.status is True)

    def processed(self):
        return (self.done is True)

    def possible(self, instances):
        for p in self.parents:
            if p not in instances:
                return False
        return True

    def runnable(self, instances):
        if self.done:
            return False
        return self.possible(instances)

    def outputDirectory(self):
        return self.out

    def buildRoot(self):
        return self.buildroot

    def generate(self, parents):
        if callable(self.gen):
            _outs = self.gen(self, parents)
            if isinstance(_outs, list):
                self.outputs = _outs
            else:
                self.outputs = [ _outs ]
        elif isinstance(self.gen, list):
            self.outputs = self.gen
        else:
            self.outputs = [ self.gen ]

        if self._validOuputs(self.outputs) is False:
            raise InvalidCombinationGenerator(self.outputs)

    def addCombinationState(self):
        if self.stateFile is None:
            self.stateFile = self.out / '.mmh-state.yaml'
        if self.stateFile.exists():
            self.data = mmh.load(self.stateFile)
        else:
            self.data = {}
        self.data['version'] = COMBINATION_STATE_FILE_VERSION
        self.data['combination'] = self.name
        self.data['timestamp'] = datetime.datetime.now(datetime.UTC)
        self.data['id'] = self.data['id'] + 1 if 'id' in self.data else 0
        self.data['mmh'] = self.mmhstate
        self.verbose(f'Generating combination state: {self.stateFile}, ' +
                     f'id = {self.data["id"]}')
        mmh.dump(self.stateFile, self.data)
        return self.data['id']

    def _checksumFile(self, file):
        # This assumes that files, once created, do not change. So once we have
        # determined the checksum of a file, we can store it and never recalcu-
        # late it again.
        if file in self.checksumCache:
            self.verbose(f'{self.checksumCache[file]}  {file} (cached)')
            return self.checksumCache[file]
        cs = mmh.checksumFile(file, self.algorithm)
        self.checksumCache[file] = cs
        self.verbose(f'{cs}  {file}')
        return cs

    def checksumFileDict(self, fn):
        checksum = self._checksumFile(fn) if fn.exists() else False
        return { 'file': str(fn),
                 'mtime': datetime.datetime.fromtimestamp(
                     os.path.getmtime(fn), datetime.UTC),
                 'checksum': checksum }

    def checksumFileDictList(self, lst):
        rv = []
        for file in lst:
            rv.append(self.checksumFileDict(file))
        return rv

    def loadOutputState(self, output):
        fn = self.out / ('.' + output.name + '.yaml')
        if fn.exists() == False:
            return (fn, None)
        self.verbose(f'{output.name}: Loading output state: {fn}')
        return (fn, mmh.load(fn))

    def addOutputState(self, ident, start, end, output, result):
        fn = self.out / ('.' + output.name + '.yaml')
        data = {}
        data['version'] = OUTPUT_STATE_FILE_VERSION
        data['id'] = ident
        data['fresh'] = ident
        data['mmh'] = self.mmhstate
        us = datetime.timedelta(microseconds=1)
        data['time'] = { 'start': start,
                         'microseconds': round((end - start) / us) }
        data['inputs'] = self.checksumFileDictList(output.inputs)
        data['output'] = self.checksumFileDict(self.out / output.name)
        data['result'] = result
        self.verbose(f'Generating output state: {fn}, id = {ident}')
        mmh.dump(fn, data)

    def updateOutputState(self, ident, output):
        (fn, data) = self.loadOutputState(output)
        data['id'] = ident
        self.verbose(f'Generating output state: {fn}, id = {ident}, ' +
                     f'fresh = {data["fresh"]}')
        mmh.dump(fn, data)

    def dispatch(self, ident, output):
        self.printer(f'{output.name}: Running generator...')
        starttime = datetime.datetime.now(datetime.UTC)
        rv = output.run(self.out)
        endtime = datetime.datetime.now(datetime.UTC)
        if isinstance(rv, Exception):
            self.log.error(f'Caught exception: {rv}')
            return False
        elif rv != True:
            self.log.error(f'Output runner did not return success.' +
                           f' Instead: {rv}')
            return False
        return ((rv == True), starttime, endtime)

    def isUpToDate(self, ident, output):
        # This is a pretty safe way to tell if an output file needs to be rege-
        # nerated or not. I hope it's not too slow. Local tests seem more than
        # fine.
        name = output.name
        file = self.out / output.name
        if file.exists() == False:
            self.printer(f'{name}: Output does not exist')
            return False
        (meta, data) = self.loadOutputState(output)
        if data is None:
            self.printer(f'{name}: Output meta-data could not be read')
            return False
        if data['version'] != OUTPUT_STATE_FILE_VERSION:
            self.printer(f'{name}: Output meta-data incompatible')
            return False
        if data['mmh'] != self.data['mmh']:
            self.printer(f'{name}: mmh program state has changed')
            return False
        chksum = self._checksumFile(file)
        if chksum != data['output']['checksum']:
            self.printer(f'{name}: Output file is inconsistent')
            return False
        oldInputs = list(map(lambda x: x['file'], data['inputs']))
        newInputs = list(map(str, output.inputs))
        if newInputs != oldInputs:
            self.printer(f'{name}: Input file spec has changed')
            return False
        for (dep, cache) in zip(output.inputs, data['inputs']):
            chksum = self._checksumFile(dep)
            if chksum != cache['checksum']:
                self.printer(f'{name}: Input file has changed {dep}')
                return False
        self.printer(f'{name}: Output file is up-to-date')
        return True

    def run(self, parents):
        self.buildroot = Path(parents[0].buildroot)
        self.mmhstate = mmh.sourceCodeState.get()
        self.verbose(f'mmh program state: {self.mmhstate}')
        self.out = self.buildroot / 'combination' / self.name
        self.verbose(f'{self.name}: Output directory: {str(self.out)}')
        self.generate(parents)
        self.done = True
        self.status = True
        if self.out.exists() == False:
            self.log.info(f'mkdir({self.out})')
            self.out.mkdir(parents = True, exist_ok = True)
        ident = self.addCombinationState()
        for output in self.outputs:
            if self.isUpToDate(ident, output):
                self.updateOutputState(ident, output)
                continue
            (rv, s, e) = self.dispatch(ident, output)
            if rv != True:
                self.status = False
            self.addOutputState(ident, s, e, output, rv)
        return self.status

    def __str__(self):
        return self.name

class ParentInstance:
    def __init__(self, log, name, buildroot, data):
        self.log = log
        self.name = name
        self.data = data
        self.buildroot = buildroot
        self.builddir = p.BuildDirectory(buildroot, self.name, self.log)
        self.sourcedir = p.SourceDirectory(self.data.instance.systemdir)

    def cmake(self, key = None, force = False):
        return self.builddir.cmake(key, force)

    def buildDirectory(self):
        return self.builddir

    def sourceDirectory(self):
        return self.sourcedir

class Registry:
    def __init__(self):
        self.combinations = {}
        self.parents = {}
        self.entry = None
        self.finish = None
        self.log = None
        self.stats = None

    def __call__(self, *args, **kwargs):
        return self.register(*args, **kwargs)

    def setCallbacks(self, entry, finish):
        self.entry = entry
        self.finish = finish

    def setLog(self, log):
        self.log = log

    def setStats(self, stats):
        self.stats = stats

    def xcount(self, pred):
        cnt = 0
        for name in self.combinations:
            c = self.combinations[name]
            if getattr(c. pred)():
                cnt = cnt + 1
        return cnt

    def countProcessed(self):
        """Return number of combinations that where processed.

        A processed combination may have been skipped (because a parent did not
        succeed), failed or succeeded."""
        return self.xcount('processed')

    def countSkipped(self):
        """Return the number of processed but skipped combinations."""
        return self.xcount('skipped')

    def countSucceeded(self):
        """Return the number of successfully processed combinations."""
        return self.xcount('succeeded')

    def countPossible(self, instances):
        """Return the number of possible combinations to be build.

        In contrast to countProcessed(), this can be run before the entire
        build-process. Given a set of build instances to be performed, the
        number of possible combinations can be computed."""
        n = 0
        for name in self.combinations:
            c = self.combinations[name]
            if c.possible(instances):
                n = n + 1
        return n

    def addParent(self, name, buildroot, data):
        self.parents[name] = ParentInstance(self.log, name, buildroot, data)

    def register(self, name, parents, cbs, **kwargs):
        """Register a build-combination.

        This registers a build combination named "name", which requires the
        list of "parents" to be build before it can be executed. The "run"
        function must accept at least two arguments, the first argument will be
        the name of the combination to be built, and the second being a list of
        ParentInstance instances, corresponding to its parent list from the
        "parents" argument.

        Any other keyword arguments are passed to the "run" function verbatim.
        It therefore will have to be able to accept those as well.

        The "run" function must return a boolean value, that indicates whether
        or not processing the combination succeeded or not."""
        if mmh.verbosity > 0:
            self.log.info(f'Registering build-combination {name} ' +
                          f'with {len(parents)} dependencies.')
        self.combinations[name] = Combination(name, parents, cbs, kwargs)

    def listParents(self, lst):
        return list(map(lambda p: self.parents[p], lst))

    def listCombinations(self):
        return list(self.combinations)

    def execute(self):
        for name in self.combinations:
            c = self.combinations[name]
            c.ensureLog(self.log)
            if (c.runnable(self.parents.keys())):
                self.stats.systemCombination(name, c.parents)
                if self.entry is not None:
                    self.entry(name)
                plst = self.listParents(c.parents)
                parentsok = True
                for p in plst:
                    success = p.data.succeeded()
                    if not success:
                        self.log.warn(f'combination({name}):' +
                                      ' {p.description} did not succeed')
                        self.log.warn(f'combination({name}): will be skipped')
                        parentsok = False
                if not parentsok:
                    c.done = True
                    self.finish(name, 'skipped')
                else:
                    rc = c.run(plst)
                    self.stats.logBuild(0 if rc else 1)
                    if self.finish is not None:
                        self.finish(name, None if rc else 'failed')

combination = Registry()

def _checksumFile(file):
    return mmh.checksumFile(file, hashlib.sha256)

def findOutputs(base):
    rv = []
    for candidate in Path(base).rglob('.*.yaml'):
        if candidate.name == '.mmh-state.yaml':
            continue
        rv.append(candidate)
    return rv

def checkDependencies(lst):
    deps = []
    summary = 'intact'
    for entry in lst:
        p = Path(entry['file'])
        data = { 'file': p }
        if p.exists() == False:
            summary = 'broken'
            data['integrity'] = 'missing'
            deps.append(data)
            continue
        chksum = _checksumFile(p)
        data['integrity'] = 'broken'
        data['expect'] = entry['checksum']
        data['actual'] = chksum
        if data['actual'] == data['expect']:
            data['integrity'] = 'intact'
        else:
            summary = 'broken'
        deps.append(data)
    return (len(deps), summary, deps)

def evaluateOutput(cdata, odata):
    file = Path(odata['output']['file'])
    isActive = cdata['id'] == odata['id']
    isFresh = isActive and odata['id'] == odata['fresh']

    state = 'stale'
    if file.exists() == False:
        state = 'missing'
    elif isFresh:
        state = 'fresh'
    elif isActive:
        state = 'active'

    if state != 'missing':
        chksum = _checksumFile(file)
        integrity = 'broken'
        if chksum == odata['output']['checksum']:
            integrity = 'intact'
    else:
        integrity = None

    (dn, ds, deps) = checkDependencies(odata['inputs'])

    return { 'combination':  cdata,
             'output':       odata,
             'id':           odata['id'],
             'fresh':        odata['fresh'],
             'file':         file,
             'name':         file.name,
             'creation':     odata['output']['mtime'],
             'isActive':     isActive,
             'isFresh':      isFresh,
             'state':        state,
             'integrity':    integrity,
             'dep-summary':  f'{dn}, {ds}',
             'dependencies': deps }

def renderOutput(data):
    print(f"  {data['name']}")
    label = 'state'
    print(f"    {label:.<14}: {data['state']} (id: {data['fresh']})")
    label = 'creation'
    print(f"    {label:.<14}: {data['creation']}")
    if data['integrity'] is not None:
        label = 'integrity'
        print(f"    {label:.<14}: {data['integrity']}")
    label = 'dependencies'
    if mmh.verbosity > 0:
        print(f"    {label:.<14}:")
        for dep in data['dependencies']:
            state = dep['integrity']
            l = 'file'
            print(f'      {l:.<10}: {dep["file"]}')
            if state == 'missing':
                l = 'state'
                print(f'      {l:.<10}: {state}')
            elif state == 'intact':
                l = 'state'
                print(f'      {l:.<10}: {state}')
                l = 'checksum'
                print(f'      {l:.<10}: {dep["actual"]}')
            elif state == 'broken':
                l = 'state'
                print(f'      {l:.<10}: {state}')
                l = 'expected'
                print(f'      {l:.<10}: {dep["expect"]}')
                l = 'actual'
                print(f'      {l:.<10}: {dep["actual"]}')
            else:
                print(f'      Unknown state: {state}')
            print('   ', '-' * 80)
    else:
        print(f"    {label:.<14}: {data['dep-summary']}")

def _combinationInterate(prefix, root, start, before = None, perOutput = None):
    for state in Path(start).rglob('.mmh-state.yaml'):
        cdata = mmh.load(state)
        if cdata['version'] != COMBINATION_STATE_FILE_VERSION:
            # We don't understand the state file version, but we can get the
            # label for the combination we can't read from the name of the
            # pathnames. So lets do that, let the user know and continue.
            label = state.relative_to(root).parent
            print(f'{label}: Incompatible state version: {cdata['version']}')
            continue
        combination = prefix + '/' + cdata['combination']
        if before is not None:
            rv = before(prefix, root, start, state, cdata, combination)
            if rv == False:
                return False
        outputs = findOutputs(state.parent)
        for output in outputs:
            odata = mmh.load(output)
            if odata['version'] != OUTPUT_STATE_FILE_VERSION:
                # Similarly to the unsupported combination format version, with
                # the output state, we can also guess the output file name from
                # the name of the state file. Again, do that and continue.
                label = output.stem[1:]
                print(f'  {label}: Incompatible output version:',
                      f'{odata['version']}')
                continue
            if perOutput is not None:
                rv = perOutput(prefix, root, start, state,
                               cdata, combination,
                               odata, output)
                if rv == False:
                    return False
    return True

def combinationOverview(prefix, root, start):
    def _before(prefix, root, start, state, cdata, combination):
        print(f'Outputs produced by {combination}:')

    def _perOutput(prefix, root, start, state,
                   cdata, combination, odata, output):
        renderOutput(evaluateOutput(cdata, odata))

    return _combinationInterate(prefix, root, start,
                                before = _before,
                                perOutput = _perOutput)

def combinationGC(prefix, root, start):
    def _perOutput(prefix, root, start, state,
                   cdata, combination, odata, output):
        data = evaluateOutput(cdata, odata)
        if data['state'] != 'stale' and data['state'] != 'missing':
            return True
        file = data['file']
        meta = file.parent / ('.' + file.name + '.yaml')

        if data['state'] == 'stale':
            print(f'Removing stale output: {file}')
        else:
            print(f'Removing output meta: {meta}')
        try:
            if file.exists():
                file.unlink()
            meta.unlink()
        except Exception as e:
            print(f'  Error: {e}')
            return False
        return True

    return _combinationInterate(prefix, root, start,
                                perOutput = _perOutput)

def combinationTool(root, log, args):
    prefix = 'combination'
    root = Path(root)
    start = root / prefix

    if args.garbage_collect:
        print('Scanning for stale combination outputs...')
        return combinationGC(prefix, root, start)

    return combinationOverview(prefix, root, start)
